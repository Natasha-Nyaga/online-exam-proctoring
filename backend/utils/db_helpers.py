import os
import json
from supabase import create_client, Client
from flask import current_app

# Supabase initialization
SUPABASE_URL = os.environ.get("SUPABASE_URL")
SUPABASE_SERVICE_KEY = os.environ.get("SUPABASE_SERVICE_KEY")

if not SUPABASE_URL or not SUPABASE_SERVICE_KEY:
    print("WARNING: Supabase URL or Service Key not found in environment variables.")

try:
    supabase: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)
except Exception as e:
    print(f"Failed to initialize Supabase client: {e}")
    class DummySupabase:
        def table(self, name): return self
        def insert(self, data): return self
        def update(self, data): return self
        def select(self, columns): return self
        def eq(self, column, value): return self
        def order(self, column, desc): return self
        def limit(self, count): return self
        def single(self): return self
        def execute(self): return self
        def error(self): return None
    supabase = DummySupabase()


def create_calibration_session(student_id: str):
    """
    Creates a new calibration session record and returns its ID.
    """
    try:
        response = supabase.table("calibration_sessions").insert({
            "student_id": student_id,
            "status": "in_progress"
        }).select("id, session_id").single().execute()
        
        return response.data["id"]
    except Exception as e:
        print(f"Error creating calibration session: {e}")
        return None


def save_personalized_thresholds(
    student_id: str, 
    session_id: str, 
    fusion_mean: float, 
    fusion_std: float, 
    calculated_threshold: float, 
    baseline_stats: dict, 
    course_name: str
):
    """
    Saves the personalized threshold and baseline statistics to the database.
    
    Args:
        student_id: UUID of the student
        session_id: UUID of the calibration session (calibration_session_id in DB)
        fusion_mean: Combined mean score across features
        fusion_std: Combined std across features
        calculated_threshold: The personalized threshold (98th percentile)
        baseline_stats: Dict containing {'keystroke': {...}, 'mouse': {...}} with detailed_stats
        course_name: Name of the course
    
    Database Schema:
        - id: uuid (auto-generated)
        - student_id: uuid
        - calibration_session_id: uuid
        - fusion_mean: numeric
        - fusion_std: numeric
        - threshold: numeric
        - baseline_stats: jsonb
        - course_name: text
        - created_at: timestamp (auto)
        - updated_at: timestamp (auto)
    """
    try:
        import uuid
        baseline_id = str(uuid.uuid4())
        
        # Prepare the baseline_stats for JSON storage
        baseline_json = json.dumps(baseline_stats)
        
        print(f"\n[DB SAVE] Saving threshold to database...")
        print(f"[DB SAVE] Student ID: {student_id}")
        print(f"[DB SAVE] Calibration Session ID: {session_id}")
        print(f"[DB SAVE] Threshold: {calculated_threshold}")
        print(f"[DB SAVE] Fusion mean: {fusion_mean}, std: {fusion_std}")
        print(f"[DB SAVE] Course: {course_name}")
        
        # Insert into personal_thresholds table
        # IMPORTANT: The column name is 'calibration_session_id' not 'session_id'
        response = supabase.table("personal_thresholds").insert({
            "id": baseline_id,
            "student_id": student_id,
            "calibration_session_id": session_id,  # Maps to calibration_session_id column
            "fusion_mean": float(fusion_mean),
            "fusion_std": float(fusion_std),
            "threshold": float(calculated_threshold),  # Maps to threshold column
            "baseline_stats": baseline_json,
            "course_name": course_name
            # created_at and updated_at are auto-generated by database defaults
        }).execute()
        
        # Check for errors
        if hasattr(response, 'error') and response.error:
            print(f"[DB ERROR] Supabase error: {response.error}")
            return False
        
        # Mark calibration session as completed
        supabase.table("calibration_sessions").update({
            "status": "completed",
            "completed_at": "now()"
        }).eq("id", session_id).execute()
        
        print(f"[DB SAVE] ✓ Threshold saved successfully! Row ID: {baseline_id}")
        return True
        
    except Exception as e:
        print(f"[DB ERROR] Failed to save personalized threshold: {e}")
        import traceback
        traceback.print_exc()
        return False


def get_student_baseline(student_id: str):
    """
    Retrieves the most recent personalized baseline for a student.
    
    Args:
        student_id: UUID of the student
    
    Returns:
        Dict with structure:
        {
            'stats': {
                'keystroke': {'detailed_stats': {feature_name: {'mean': x, 'std': y}, ...}},
                'mouse': {'detailed_stats': {feature_name: {'mean': x, 'std': y}, ...}}
            },
            'system_threshold': float
        }
        
        Returns None if no baseline found.
    """
    try:
        print(f"\n[DB FETCH] Retrieving baseline for student: {student_id}")
        
        # Fetch the most recent baseline for this student
        response = supabase.table("personal_thresholds")\
            .select("baseline_stats, threshold")\
            .eq("student_id", student_id)\
            .order("created_at", desc=True)\
            .limit(1)\
            .execute()
        
        if not response.data or len(response.data) == 0:
            print(f"[DB FETCH] No baseline found for student {student_id}")
            return None
        
        baseline_data = response.data[0]
        baseline_stats_raw = baseline_data.get("baseline_stats")
        threshold = baseline_data.get("threshold")
        
        if not baseline_stats_raw:
            print(f"[DB FETCH] Baseline stats missing in database")
            return None
        
        # Parse the JSON baseline stats (it might already be a dict or a string)
        if isinstance(baseline_stats_raw, str):
            baseline_stats = json.loads(baseline_stats_raw)
        else:
            baseline_stats = baseline_stats_raw
        
        # Construct the result in the expected format
        result = {
            "stats": baseline_stats,  # Should contain {'keystroke': {...}, 'mouse': {...}}
            "system_threshold": float(threshold)
        }
        
        print(f"[DB FETCH] ✓ Baseline retrieved successfully")
        print(f"[DB FETCH] Threshold: {threshold}")
        print(f"[DB FETCH] Has keystroke stats: {'keystroke' in baseline_stats}")
        print(f"[DB FETCH] Has mouse stats: {'mouse' in baseline_stats}")
        
        return result
        
    except Exception as e:
        print(f"[DB ERROR] Failed to retrieve baseline: {e}")
        import traceback
        traceback.print_exc()
        return None


def save_anomaly_record(session_id: str, final_risk_score: float, incident_details: dict):
    """
    Logs a cheating incident to the database.
    
    Args:
        session_id: UUID of the exam session
        final_risk_score: The fusion risk score that triggered the alert
        incident_details: Dict with breakdown of scores and metadata
    
    Database Schema (cheating_incidents):
        - id: uuid (auto-generated)
        - session_id: uuid
        - incident_type: text
        - description: text
        - severity: text ('low', 'medium', 'high')
        - severity_score: numeric
        - details: jsonb
        - timestamp: timestamp (auto)
    """
    try:
        # Determine severity based on risk score
        if final_risk_score >= 0.8:
            severity = "high"
        elif final_risk_score >= 0.6:
            severity = "medium"
        else:
            severity = "low"
        
        # Insert incident record
        supabase.table('cheating_incidents').insert({
            'session_id': session_id,
            'incident_type': 'behavioral_anomaly',
            'description': f"Fusion risk score of {final_risk_score:.2f} detected",
            'severity_score': float(final_risk_score),
            'severity': severity,
            'details': json.dumps(incident_details)
            # timestamp is auto-generated
        }).execute()
        
        print(f"[DB SAVE] ✓ Anomaly record saved (severity: {severity}, score: {final_risk_score:.2f})")
        return True
        
    except Exception as e:
        print(f"[DB ERROR] Failed to save anomaly record: {e}")
        import traceback
        traceback.print_exc()
        return False


def get_student_incident_count(session_id: str):
    """
    Gets the total number of incidents for a given exam session.
    
    Args:
        session_id: UUID of the exam session
        
    Returns:
        int: Number of incidents recorded
    """
    try:
        response = supabase.table('cheating_incidents')\
            .select('id', count='exact')\
            .eq('session_id', session_id)\
            .execute()
        
        return response.count if hasattr(response, 'count') else 0
        
    except Exception as e:
        print(f"[DB ERROR] Failed to count incidents: {e}")
        return 0